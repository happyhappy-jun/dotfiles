#!/usr/bin/env bash
# Main bash configuration file
# This file is managed by chezmoi and sources common functionality

# ============================================================================
# Early Setup - Performance Critical
# ============================================================================

# Only run if this is an interactive shell
[[ $- != *i* ]] && return

# CRITICAL: Initialize PATH early if empty or broken (before sourcing any scripts)
# This prevents "command not found" errors
# Check if PATH is empty, unset, or doesn't contain critical system paths
if [ -z "$PATH" ] || [ "$PATH" = "" ] || [[ "$PATH" != *"/usr/bin"* ]] || [[ "$PATH" != *"/bin"* ]]; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
        export PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/homebrew/bin"
    else
        export PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    fi
fi

# Source common paths first (lightweight)
# Try multiple locations to support different chezmoi setups
COMMON_DIR=""
for dir in "$HOME/.common" "$HOME/dot_common" "$(chezmoi source-path 2>/dev/null)/dot_common"; do
    if [ -d "$dir" ]; then
        COMMON_DIR="$dir"
        break
    fi
done

if [ -n "$COMMON_DIR" ]; then
    [ -f "$COMMON_DIR/paths.sh" ] && source "$COMMON_DIR/paths.sh"
    [ -f "$COMMON_DIR/lazy_load.sh" ] && source "$COMMON_DIR/lazy_load.sh"
    [ -f "$COMMON_DIR/env_manager.sh" ] && source "$COMMON_DIR/env_manager.sh"
    [ -f "$COMMON_DIR/tmux_setup.sh" ] && source "$COMMON_DIR/tmux_setup.sh"
fi

# ============================================================================
# Bash-Specific Configuration
# ============================================================================

# History configuration
export HISTSIZE=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoreboth:erasedups
export HISTIGNORE="ls:ll:la:cd:exit:clear:history"

# Append to history file instead of overwriting
shopt -s histappend

# Check window size after each command
shopt -s checkwinsize

# Enable ** globbing (bash 4+)
shopt -s globstar 2>/dev/null

# Enable case-insensitive globbing
shopt -s nocaseglob 2>/dev/null

# ============================================================================
# Lazy Loading Setup for Heavy Tools
# ============================================================================

# Lazy load Node Version Manager (nvm)
if [ -d "$HOME/.nvm" ]; then
    lazy_load nvm -- 'export NVM_DIR="$HOME/.nvm" && [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"'
    # Also lazy load node, npm, and npx
    lazy_load_multi node npm npx -- 'export NVM_DIR="$HOME/.nvm" && [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"'
fi

# Lazy load Fast Node Manager (fnm)
if [ -d "$HOME/.fnm" ]; then
    lazy_load fnm -- 'eval "$(fnm env --use-on-cd)"'
    lazy_load_multi node npm npx -- 'eval "$(fnm env --use-on-cd)"'
fi

# Lazy load Python Version Manager (pyenv)
if [ -d "$HOME/.pyenv" ]; then
    lazy_load pyenv -- 'export PYENV_ROOT="$HOME/.pyenv" && export PATH="$PYENV_ROOT/bin:$PATH" && eval "$(pyenv init -)"'
    lazy_load_multi python python3 pip pip3 -- 'export PYENV_ROOT="$HOME/.pyenv" && export PATH="$PYENV_ROOT/bin:$PATH" && eval "$(pyenv init -)"'
fi

# Lazy load Ruby Version Manager (rbenv)
if [ -d "$HOME/.rbenv" ]; then
    lazy_load rbenv -- 'export PATH="$HOME/.rbenv/bin:$PATH" && eval "$(rbenv init -)"'
    lazy_load_multi ruby gem bundle -- 'export PATH="$HOME/.rbenv/bin:$PATH" && eval "$(rbenv init -)"'
fi

# Lazy load Rust (cargo)
if [ -f "$HOME/.cargo/env" ]; then
    lazy_load cargo -- 'source "$HOME/.cargo/env"'
    lazy_load rustc -- 'source "$HOME/.cargo/env"'
fi

# Lazy load Go
if [ -d "$HOME/.go" ]; then
    lazy_load go -- 'export PATH="$HOME/.go/bin:$PATH"'
fi

# Lazy load Conda (miniconda3/anaconda3)
# Conda initialization is slow, so we lazy load it
if [ -d "$HOME/miniconda3" ] && [ -f "$HOME/miniconda3/etc/profile.d/conda.sh" ]; then
    lazy_load conda -- 'source "$HOME/miniconda3/etc/profile.d/conda.sh"'
    # Also lazy load python, pip when conda is used
    # Note: These will only work after conda is initialized
    lazy_load_multi python python3 pip pip3 -- 'source "$HOME/miniconda3/etc/profile.d/conda.sh"'
elif [ -d "$HOME/miniconda" ] && [ -f "$HOME/miniconda/etc/profile.d/conda.sh" ]; then
    # Fallback for older miniconda installations
    lazy_load conda -- 'source "$HOME/miniconda/etc/profile.d/conda.sh"'
    lazy_load_multi python python3 pip pip3 -- 'source "$HOME/miniconda/etc/profile.d/conda.sh"'
elif [ -d "$HOME/anaconda3" ] && [ -f "$HOME/anaconda3/etc/profile.d/conda.sh" ]; then
    lazy_load conda -- 'source "$HOME/anaconda3/etc/profile.d/conda.sh"'
    lazy_load_multi python python3 pip pip3 -- 'source "$HOME/anaconda3/etc/profile.d/conda.sh"'
elif [ -d "$HOME/anaconda" ] && [ -f "$HOME/anaconda/etc/profile.d/conda.sh" ]; then
    # Fallback for older anaconda installations
    lazy_load conda -- 'source "$HOME/anaconda/etc/profile.d/conda.sh"'
    lazy_load_multi python python3 pip pip3 -- 'source "$HOME/anaconda/etc/profile.d/conda.sh"'
fi

# ============================================================================
# Source Common Functionality (Lazy Loaded)
# ============================================================================

# Function to lazy load common aliases and functions
_load_common_config() {
    # Find common directory (reuse if already found)
    if [ -z "$COMMON_DIR" ]; then
        for dir in "$HOME/.common" "$HOME/dot_common" "$(chezmoi source-path 2>/dev/null)/dot_common"; do
            if [ -d "$dir" ]; then
                COMMON_DIR="$dir"
                break
            fi
        done
    fi
    
    if [ -n "$COMMON_DIR" ]; then
        [ -f "$COMMON_DIR/aliases.sh" ] && source "$COMMON_DIR/aliases.sh"
        [ -f "$COMMON_DIR/functions.sh" ] && source "$COMMON_DIR/functions.sh"
    fi
}

# Load common config immediately (can be made lazy if needed)
_load_common_config

# ============================================================================
# Environment Variable Management
# ============================================================================

# Hook into directory changes to reload .env files
# This runs before each prompt (when directory might have changed)
# Guard against re-initialization to prevent infinite PROMPT_COMMAND recursion
if [ -n "$COMMON_DIR" ] && [ -f "$COMMON_DIR/env_manager.sh" ] && [ -z "$_ENV_MANAGER_INITIALIZED" ]; then
    _ENV_MANAGER_INITIALIZED=1
    
    # Create wrapper that checks env (don't chain PROMPT_COMMAND to avoid recursion)
    _env_manager_prompt_wrapper() {
        _check_and_reload_env 2>/dev/null || true
    }
    
    # Append to PROMPT_COMMAND instead of replacing (safer)
    if [ -z "$PROMPT_COMMAND" ]; then
        PROMPT_COMMAND="_env_manager_prompt_wrapper"
    else
        PROMPT_COMMAND="_env_manager_prompt_wrapper;$PROMPT_COMMAND"
    fi
fi

# ============================================================================
# Completion
# ============================================================================

# Enable programmable completion
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    # Lazy load bash completion
    lazy_load _bash_completion -- 'source /etc/bash_completion'
fi

# Load autocomplete scripts for various tools (git, docker, kubectl, etc.)
if [ -n "$COMMON_DIR" ] && [ -f "$COMMON_DIR/completions.sh" ]; then
    source "$COMMON_DIR/completions.sh"
elif [ -f "$HOME/.common/completions.sh" ]; then
    source "$HOME/.common/completions.sh"
elif [ -f "$HOME/dot_common/completions.sh" ]; then
    source "$HOME/dot_common/completions.sh"
fi

# ============================================================================
# Prompt Customization
# ============================================================================

# Load Starship prompt (https://starship.rs/)
# Uses Pure preset theme for a clean, minimal look
if [ -n "$COMMON_DIR" ] && [ -f "$COMMON_DIR/prompts/starship.sh" ]; then
    source "$COMMON_DIR/prompts/starship.sh"
elif [ -f "$HOME/.common/prompts/starship.sh" ]; then
    source "$HOME/.common/prompts/starship.sh"
elif [ -f "$HOME/dot_common/prompts/starship.sh" ]; then
    source "$HOME/dot_common/prompts/starship.sh"
else
    # Fallback: Try starship directly if available
    if command -v starship >/dev/null 2>&1; then
        eval "$(starship init bash)"
    fi
fi

# ============================================================================
# History Substring Search
# ============================================================================

# Load history substring search functionality
if [ -n "$COMMON_DIR" ] && [ -f "$COMMON_DIR/history_search.sh" ]; then
    source "$COMMON_DIR/history_search.sh"
elif [ -f "$HOME/.common/history_search.sh" ]; then
    source "$HOME/.common/history_search.sh"
elif [ -f "$HOME/dot_common/history_search.sh" ]; then
    source "$HOME/dot_common/history_search.sh"
fi

# ============================================================================
# Final Setup
# ============================================================================

# Source machine-specific bashrc if it exists (not managed by chezmoi)
if [ -f "$HOME/.bashrc.local" ]; then
    source "$HOME/.bashrc.local"
fi
